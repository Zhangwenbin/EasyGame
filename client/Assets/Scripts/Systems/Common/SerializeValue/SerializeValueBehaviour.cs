using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using CSharpHelpers;
using System;

namespace EG
{
    [AddComponentMenu("Scripts/System/Common/SerializeValueBehaviour")]
    public class SerializeValueBehaviour : UnityEngine.MonoBehaviour, IPrefabSaveHook
    {
        [SerializeField] SerializeValueList m_List = new SerializeValueList();
        private bool m_Initialized   = false;
        public SerializeValueList list { get { return m_List; } }
        void Awake( )
        {
            if( m_Initialized == false )
            {
                m_List.Initialize( );
                m_Initialized = true;
            }
        }
        public void Initialize( )
        {
            if( m_Initialized == false )
            {
                m_List.Initialize( );
                m_Initialized = true;
            }
        }
        public void Release( )
        {
            if( m_Initialized )
            {
                m_List.Reset( );
                m_Initialized = false;
            }
        }

#if UNITY_EDITOR
        [ContextMenu("OpenKeyFileInEditor")]
        public void OpenKeyFileInEditor()
        {
            var path = UnityEditor.PrefabUtility.GetPrefabAssetPathOfNearestInstanceRoot(gameObject);
            if (string.IsNullOrEmpty(path))
            {
                var stage = UnityEditor.Experimental.SceneManagement.PrefabStageUtility.GetPrefabStage(gameObject);
                if (stage == null || string.IsNullOrEmpty(stage.prefabAssetPath))
                {
                    return;
                }
                path = stage.prefabAssetPath;
            }

            GenerateKeyFilePath(path, out var prefabName, out var className, out var filePath, out var ns);
            if (System.IO.File.Exists(filePath))
            {
                UnityEditor.EditorGUIUtility.PingObject(UnityEditor.AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(filePath));
                UnityEditorInternal.InternalEditorUtility.OpenFileAtLineExternal(filePath, 3);
            }
        }

        void GenerateKeyFilePath(string prefabPath, out string prefabName, out string className, out string filePath, out string ns)
        {
            prefabName = System.IO.Path.GetFileNameWithoutExtension(prefabPath);
            var hierarchy = EditorHelp.GetHierarchyPath(transform);
            for (var i = 0; i < hierarchy.Count; ++i)
            {
                hierarchy[i] = EditorHelp.ToSafeSymbolName(hierarchy[i]);
            }

            className = string.Join("_", hierarchy) + "Keys";
            filePath = $"Assets/Scripts/AutoGenerated/SerializeValueBehaviour/{prefabName}/{className}.cs";
            ns = "GFSYS.AutoGenerated.ValueKeys";
        }
        
        class SaveContext
        {
            internal static HashSet<string> IgnoreObjectNames = new HashSet<string>
            {
                "root", "tutorial_value_list", "eff_root",
            };
            public List<string> Files = new List<string>();
            public HashSet<int> Hashes = new HashSet<int>();
        }
#endif

        public bool OnDidSavePrefab(string path, TypedContext context)
        {
#if UNITY_EDITOR
            if (!EditorInspector_SerializeValueBehaviour.IsDumpSerializeValueKeys)
            {
                return false;
            }

            GenerateKeyFilePath(path, out var prefabName, out var className, out var filePath, out var ns);

            var keys = new List<string>();
            foreach (var data in m_List.list)
            {
                if (keys.Contains(data.key))
                {
                    Debug.LogWarning("DuplicateKey: " + data.key);
                    continue;
                }
                keys.Add(data.key);
            }

            var getComments = new Func<List<string>>(() =>
            {
                var comments = new List<string>();
                foreach (var key in keys)
                {
                    var value = m_List.GetField(key);
                    if (value == null)
                    {
                        continue;
                    }

                    var t = value.v_Tranform;
                    if (t == null)
                    {
                        comments.Add($"{value.type.GetName()} {value.GetValueString()}");
                    }
                    else
                    {
                        var hierarchy = EditorHelp.GetHierarchyPath(t);
                        hierarchy.RemoveAt(0);
                        comments.Add($"{value.type.GetName()} http://127.0.0.1:4649/open?t={string.Join("/", hierarchy)}&name={prefabName}.prefab");
                    }
                }
                return comments;
            });

            var getHeader = new Func<List<string>>(() =>
            {
                var header = new List<string>();
                header.Add("prefab:" + path);
                header.Add("guid:" + UnityEditor.AssetDatabase.AssetPathToGUID(path));
                header.Add("localId:" + EditorHelp.GetLocalID(gameObject).ToString());
                header.Add("transform:" + string.Join("/", EditorHelp.GetHierarchyPath(transform)));
                return header;
            });

            var files = context.GetOrCreate<SaveContext>().Files;

            var needsDump = (
                !context.Get<PrefabSaveHookContext>().IsNested &&
                keys.Count > 0 &&
                !SaveContext.IgnoreObjectNames.Contains(name)
            );

            if (needsDump)
            {
                var hash = EditorHelp.ComputeKeysHash(keys);
                var hashes = context.GetOrCreate<SaveContext>().Hashes;
                if (hashes.Contains(hash))
                {
                    needsDump = false;
                }
                hashes.Add(hash);
            }

            if (needsDump)
            {
                files.Add(filePath);
            }

            var saved = false;
            if (context.Get<PrefabSaveHookContext>().IsLast(this))
            {
                // Debug.Log(string.Join(",", files));
                var dir = System.IO.Path.GetDirectoryName(filePath);
                if (System.IO.Directory.Exists(dir))
                {
                    foreach (var file in System.IO.Directory.GetFiles(dir, "*.cs"))
                    {
                        if (!files.Contains(file.Replace('\\', '/')))
                        {
                            System.IO.File.Delete(file);
                            saved = true;
                        }
                    }
                }
            }

            if (needsDump)
            {
                saved |= EditorHelp.DumpStringKeysClassFile(filePath, ns, className, keys, getComments, getHeader);
            }

            if (saved) return saved;
#endif
            return false;
        }
    }

    public static class SerializeValueBehaviourExtension
    {
        public static SerializeValueList GetValueList( this GameObject self)
        {
            return self?.GetComponent<SerializeValueBehaviour>()?.list;
        }
        
        public static SerializeValueList GetValueList(this Component self)
        {
            return self?.GetComponent<SerializeValueBehaviour>()?.list;
        }

        public static SerializeValueList GetTutorialValueList ( this GameObject self )
        {
            return self?.GetValueList( )?.GetComponent<SerializeValueBehaviour>( "tutorial_value_list" )?.list;
        }

        public static SerializeValueList GetTutorialValueList ( this Component self )
        {
            return self?.GetValueList( )?.GetComponent<SerializeValueBehaviour>( "tutorial_value_list" )?.list;
        }
    }
    
    #if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(SerializeValueBehaviour))]
    public class EditorInspector_SerializeValueBehaviour : UnityEditor.Editor
    {
        const string MenuItemLabel = "GFSYS/AutoGenerated/SerializeValueBehaviour Key";

        public static bool IsDumpSerializeValueKeys
        {
            get => UnityEditor.EditorPrefs.GetBool("GFSYS.SerializeValueBehaviour.OnDidSavePrefab", false);
            set => UnityEditor.EditorPrefs.SetBool("GFSYS.SerializeValueBehaviour.OnDidSavePrefab", value);
        }

        [UnityEditor.MenuItem(MenuItemLabel)]
        public static void DumpSerializeValueKeys()
        {
            IsDumpSerializeValueKeys = !IsDumpSerializeValueKeys;
        }

        [UnityEditor.MenuItem(MenuItemLabel, true)]
        public static bool DumpSerializeValueKeysChecked()
        {
            UnityEditor.Menu.SetChecked(MenuItemLabel, IsDumpSerializeValueKeys);
            return true;
        }

        [UnityEditor.MenuItem("GameObject/AddtoSerializeValueBehaviour", false, 15)]
        public static void AddGameObjectToParentSerializeValueBehaviour()
        {
            var go = UnityEditor.Selection.activeGameObject;
            var parents = go.GetComponentsInParent<SerializeValueBehaviour>(true);
            if (parents.Length == 0)
            {
                return;
            }

            var target = parents[0];  // nearest
            target.list.AddField(go.name, go);
            UnityEditor.EditorGUIUtility.PingObject(target);
        }

        [UnityEditor.MenuItem("GameObject/AddtoSerializeValueBehaviour", true)]
        public static bool AddGameObjectToParentSerializeValueBehaviourValidate()
        {
            var go = UnityEditor.Selection.activeGameObject;
            return go && go.transform.parent;
        }

        public override void OnInspectorGUI( )
        {
            SerializeValueBehaviour obj = target as SerializeValueBehaviour;
            if( obj != null )
            {
                obj.list.OnGUIInspect( obj );
            }
        }
    }
    #endif
}
